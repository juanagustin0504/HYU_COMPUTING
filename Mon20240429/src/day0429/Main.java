package day0429;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 정적 배열: 크기 고정
		// 동적 배열: 크기 변경 가능
		
//		int[] a = {1, 4, 7};
		// 정적배열 장점
		// Access 속도가 매우 빠름
		// 배열을 만들 때 100개를 만들 상황이 생긴다면
		// 초기 배열 크기도 100으로 설정해야 됨.
		// ㅈㄴ비효율적
		// 근데 속도는 ㅈ나 빠름
		// 메모리 충분한 사람들
		
		// 동적배열 장점
		// 속도는 느림
		// 효율적
		
		// 포인터 타입
//		int[] a = new int[3]; 
		// new int[3]을 먼저함. 메모리 랜덤한 곳. 16진수
		// a라는 곳에 첫번째 메모리 주소가 들어감
		// 포인터 타입 4byte. 메모리주소(16진수).
		// 1. 임의 메모리 공간에 int 3개짜리로 선언하고 처음 메모리 주소를 변환
		// 2. 메모리 주소를 0에 저장, 이대 a는 포인터 타입으로 주소만 저장할 수 있음.
		// '참조'라고 한다. (메모리 주소를 저장함) reference
		
//		System.out.println(a);
		
//		a[0] = 4;
//		a[1] = 2;
//		a[2] = 8;
//		a[0] = a[1] + a[2];
		
		// a[0] = ?
		// a가 갖고 있는 주소를 찾아서 값을 가져오거나 변경시킨다.
		
//		int[] a = new int[2];
//		a[0] = 10;
//		a[1] = 5;
//		
//		int[] b = new int[3];
//		b[0] = 5; b[1] = 2; b[2] = 7;
		
//		a = 8; 안됨, 메모리 주소만 저장
//		b = a;
//		b[0] = 7;
//		System.out.println(a[0]);
		// 메모리 누수가 발생됨
		// Java에서는 가비지컬렉션(Garbage Collector 가 있어서 발생하지 않음.)
		
//		int a = 5;
//		double[] b = new double[a];
//		System.out.println(b.length);
		
//		int[][] ab = new int[3][2];
		// 포인터의 주소를 저장할 수 있는 또 다른 포인터
		// 포인터 변수의 포인터 변수...
		
		// 누나 이자카야 괜찮음?
		// 사케 개 좋은데
		
		// 메모리 주소 복사
//		int[][] ab = new int[3][2];
//		ab[0][1] = 10;
//		
//		int[][] cd = ab;
//		System.out.println(cd[0][1]);
		
		
		// 값 복사
//		int a = 3;
//		int b = a;
		
		int[][] de = new int[3][];
		de[0] = new int[2];
		de[1] = new int[4];
		de[2] = new int[5];
		// ex int[][] a = {{1,2,3},
						// {1,2},
						// {1,2,3,4,5,6,7}};
		// 행렬 형식으로 어캐하노
		//2x+3y=2.7
		//4x+5y=7.3
		// (a b)(x) = (m) // a*x+b*y=m
		// (c d)(y) = (n) // c*x+d*y=n
		
		// (a b c)(x) = (m) // a*x+b*y+c*z=m
		// (d e f)(y) = (n) // d*x+e*y+f*z=n
		// (g h i)(z) = (p) // g*x+h*y+i*z=p
		
		int[][] a = {{3,2,4},
					 {4,2,1},
					 {1,1,7}};
		int[] 	b = {1,3,2};
		int[] 	c = new int[3];
		
//		c[0] = a[0][0]*b[0] + a[0][1]*b[1] + a[0][2]*b[2];
//		c[1] = a[1][0]*b[0] + a[1][1]*b[1] + a[1][2]*b[2];
//		c[2] = a[2][0]*b[0] + a[2][1]*b[1] + a[2][2]*b[2];
		
		// 행렬과 벡터의 곱셈
//		for(int i = 0; i < a.length; i++) {
//			c[i] = 0;
//			for(int j = 0; j < a[i].length; j++) {
//				c[i] += a[i][j]*b[j];
//			}
//		}
//		
//		for(int i = 0; i < a.length; i++) {
//			System.out.println(c[i]);
//		}
		// ㄹㅈㄷ,,,,,,,
		// 나도 지금 처음보는거라 보면서 그냥 어,, 
		
		// 수학 울렁증 있어요,,
		// 이걸 array 형식으로 푼대요,,
		// ㅇㅇ 어쩔수없지 우리가 메뉴 먼저 정햇다고해야지
		// 근데 이자카야 기대중인거면 살짝 ㄸ
		// 어차피 소주 먹기로 한거 난 주말동안 삼소2번먹음
		// 근데도 맛잇음
		// 소주 도핑 기간임
		
		// array 만드는 건 알지,,?
		// 앞에서 하고 있는건 지금 3x3=9 공간을 만들어놓고
		// 0-9번까지 돌면서
		// b라는 배열과 곱해줘서 c라는 배열에 저장해주는 걸 만들고 잇는건데
		// 3x3 배열은a이고(곱해지는 수?) 
		// 3x1 배열은 b(곱해줄 수)
		// 3x1 배열은 c(저장해주는 용도)
		// 앞에 있는 3은 행
		// 그래서 a의 첫번째 행
		// a가 3x3 공간
		// int[][] a = new int[3][3];
		// a는 곱해질 수
		// a = {{1,2,3},
		//		{4,5,6},
		//		{7,8,9}}
		// b는 곱해줄 수니까 곱해줄 수를 저장해놓은 공간
		// b = {1,
		//		2,
		//		3}
		// c 저장해줄 공간이니까 (누적) 0으로 초기화 시켜준거고
		// c = {0,
		// 		0,
		//		0}
		// 반복문을 이용해서
		// a[0] 첫번째 행 1,2,3 과
		// b의 1,2,3
		// 1*1 + 2*2 + 3*3
		// 결과를 c[0] = 저장
		// c[0] = a[0][0] * b[0] + a[0][1] * b[1] + a[0][2] * b[2];
		// 첫번째 줄 끝
		// 이거를 2, 3번째 줄 까지 반복
		// a[1] = 4,5,6
		// b 1,2,3
		//   4,5,6
		// c[1] = a[1][0] * b[0] + a[1][1] * b[1] + a[1][2] * b[2];
		
//		3번 반복
		for(int i = 0; i < 3; i++) { // 3행
			// c[0] = a[0] 번째 줄 * b 1,2,3 이랑 곱해주는 작업
			// c[1] = a[1] 번째 줄 * b 1,2,3 이랑 곱해주는 작업
			// c[2] = a[2] 번째 줄 * b 1,2,3 이랑 곱해주는 작업
			for(int j = 0; j < 3; j++) { // 원소의 번호
				// a[0][0] * b[0] + a[0][1] * b[1] + a[0][2] * b[1]
				
				c[i] += a[i][j] * b[j];
				
			}
			System.out.println(c[i]);
		}
		
		

		// H.W
		// 3 2 1
		// 2 1 3
		// 2 2 4
		
		// 3 2
		// 1 2
		// 1 4
		
		// H.W2
		// 행열의 덧셈
		// a 배열이 m*n 이면 b 배열도 m*n, 그럼 c 배열도 m*n 
		
		
		
	}

}
